import asyncio
import json
from typing import Dict, List
from batch_processor import BatchProcessor

class CurriculumContentGenerator:
    def __init__(self):
        self.processor = BatchProcessor(batch_size=5)
        self.terminology = {}
        self.dialogues = {}
        
    def extract_curriculum_terminology(self, curriculum_file: str) -> Dict:
        """Extract and organize terminology from curriculum"""
        # First read the curriculum file
        with open(curriculum_file, 'r', encoding='utf-8') as f:
            curriculum = f.read()
            
        # Extract key terms and their Arabic equivalents
        # This would be customized based on your curriculum format
        # For now, using the existing terminology file
        with open('math_terminology_bilingual.txt', 'r', encoding='utf-8') as f:
            terminology_content = f.read()
        
        # Parse and organize terminology
        current_category = None
        for line in terminology_content.split('\n'):
            if line.strip():
                if line.endswith(')'):  # Category line
                    parts = line.split('(')
                    current_category = parts[0].strip()
                elif '-' in line:  # Term line
                    eng, ar = line.split('-')
                    term = {
                        'english': eng.strip().strip('- '),
                        'arabic': ar.strip().strip('- '),
                        'category': current_category
                    }
                    self.terminology[term['english']] = term
        
        # Save organized terminology
        with open('generated_lessons/glossary.json', 'w', encoding='utf-8') as f:
            json.dump(self.terminology, f, ensure_ascii=False, indent=2)
            
        return self.terminology

    async def generate_dialogue(self, topic: Dict) -> str:
        """Generate engaging dialogue using curriculum terminology"""
        # Create a dialogue prompt that emphasizes:
        # 1. Natural conversation
        # 2. Student engagement
        # 3. Correct terminology usage
        dialogue_prompt = f"""
        Generate an engaging educational dialogue in Arabic between a teacher and students about {topic['subtopic']}.
        
        Requirements:
        1. Use these specific Arabic mathematical terms:
        {self.get_relevant_terms(topic)}
        
        2. Make the dialogue interactive and engaging:
        - Include student questions showing curiosity
        - Use real-world examples
        - Include moments of discovery
        - Show student understanding progression
        
        3. Structure:
        - Start with an engaging introduction
        - Include 3-4 key concept explanations
        - Show student questions and realizations
        - End with understanding confirmation
        
        4. Format the output as a JSON dialogue with exchanges.
        """
        
        # Here you would call your LLM with the prompt
        # For now, returning a sample structure
        dialogue = {
            "topic": topic['subtopic'],
            "dialogue_ar": {
                "exchanges": [
                    {
                        "teacher": "اليوم سنتعلم عن " + topic['subtopic'],
                        "student": "هل يمكن أن تشرح لنا المزيد؟"
                    }
                    # More exchanges would be generated by LLM
                ]
            }
        }
        
        # Save dialogue for this topic
        self.dialogues[topic['topic']] = dialogue
        return dialogue

    def get_relevant_terms(self, topic: Dict) -> List[str]:
        """Get terminology relevant to this topic"""
        # This would be more sophisticated in practice,
        # matching terms to topics based on curriculum mapping
        relevant_terms = []
        for term in self.terminology.values():
            # Add logic to match terms to topics
            relevant_terms.append(f"{term['english']}: {term['arabic']}")
        return relevant_terms

    async def generate_skills_from_dialogue(self, dialogue: Dict) -> List[Dict]:
        """Extract skills based on the generated dialogue"""
        # Create prompt that analyzes dialogue to identify skills
        skills_prompt = f"""
        Analyze this educational dialogue and identify the key skills being taught.
        
        Dialogue:
        {json.dumps(dialogue, ensure_ascii=False)}
        
        Requirements:
        1. Identify skills demonstrated in the dialogue
        2. Use terminology from the dialogue
        3. Include skill progression
        4. Map to curriculum objectives
        """
        
        # Here you would call your LLM with the prompt
        # For now, returning a sample structure
        skills = [
            {
                "name_ar": "مهارة ١",
                "description_ar": "وصف المهارة",
                "dialogue_reference": "relevant part of dialogue",
                "terminology_used": ["term1", "term2"]
            }
        ]
        return skills

    async def generate_questions_from_dialogue_and_skills(
        self, 
        dialogue: Dict, 
        skills: List[Dict]
    ) -> List[Dict]:
        """Generate questions based on dialogue and identified skills"""
        # Create prompt that uses dialogue context for natural questions
        questions_prompt = f"""
        Generate assessment questions based on this educational dialogue and skills.
        
        Dialogue:
        {json.dumps(dialogue, ensure_ascii=False)}
        
        Skills:
        {json.dumps(skills, ensure_ascii=False)}
        
        Requirements:
        1. Questions should reflect the dialogue's context
        2. Use terminology from the dialogue
        3. Test identified skills
        4. Include real-world applications discussed
        """
        
        # Here you would call your LLM with the prompt
        # For now, returning a sample structure
        questions = [
            {
                "text_ar": "سؤال يعتمد على الحوار",
                "type": "multiple_choice",
                "choices": ["خيار ١", "خيار ٢", "خيار ٣", "خيار ٤"],
                "correct_answer": "خيار ١",
                "skill_reference": "مهارة ١",
                "dialogue_context": "relevant part of dialogue"
            }
        ]
        return questions

    async def process_topic(self, topic: Dict):
        """Process a single topic through all generation stages"""
        try:
            # 1. Generate engaging dialogue
            dialogue = await self.generate_dialogue(topic)
            
            # 2. Extract skills from dialogue
            skills = await self.generate_skills_from_dialogue(dialogue)
            
            # 3. Generate questions based on dialogue and skills
            questions = await self.generate_questions_from_dialogue_and_skills(
                dialogue, skills
            )
            
            # 4. Combine everything into lesson content
            lesson_content = {
                "topic": topic['topic'],
                "subtopic": topic['subtopic'],
                "grade": topic['grade'],
                "unit": topic['unit'],
                "dialogue": dialogue,
                "skills": skills,
                "questions": questions
            }
            
            # 5. Save lesson content
            filename = f"generated_lessons/lesson_{topic['grade']}_{topic['topic']}.json"
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(lesson_content, f, ensure_ascii=False, indent=2)
            
            return lesson_content
            
        except Exception as e:
            print(f"Error processing topic {topic['topic']}: {str(e)}")
            return None

async def main():
    generator = CurriculumContentGenerator()
    
    # 1. Extract and organize terminology
    print("Extracting curriculum terminology...")
    generator.extract_curriculum_terminology('math_terminology_bilingual.txt')
    
    # 2. Process each topic
    topics = [
        {
            'topic': 'multiplication',
            'subtopic': 'جدول الضرب',
            'grade': 3,
            'unit': 1
        }
        # Add more topics as needed
    ]
    
    print(f"\nProcessing {len(topics)} topics...")
    for topic in topics:
        print(f"\nProcessing {topic['subtopic']}...")
        await generator.process_topic(topic)
    
    print("\nContent generation complete!")

if __name__ == "__main__":
    asyncio.run(main())
